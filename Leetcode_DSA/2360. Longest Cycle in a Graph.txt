// simple cycle detection using dfs in directed graph (depth is for counting cycle length)
class Solution {
public:
    int res = -1;
    void dfs(vector<int>& edges, int index, vector<bool>& visited, vector<bool>& inrecursion, vector<int>& depth, int count) {
        visited[index] = true;
        inrecursion[index] = true;
        depth[index] = count;

        if (edges[index] != -1) {
            if (!visited[edges[index]]) {
                dfs(edges, edges[index], visited, inrecursion, depth, count + 1);
            } else if (inrecursion[edges[index]]) {
                res = max(res,(count-depth[edges[index]]+1));
            }
        }
        inrecursion[index] = false;
    }
    int longestCycle(vector<int>& edges) {
        int n = edges.size();
        vector<bool> visited(n, false);
        vector<bool> inrecursion(n, false);
        vector<int> depth(n, 0);
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(edges, i, visited, inrecursion, depth, 0);
            }
        }
        return res;
    }
};