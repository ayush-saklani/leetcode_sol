class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        unordered_map<int, vector<pair<int, int>>> m;
        // converting it into directed graph
        for (int i = 0; i < flights.size(); i++) {
            m[flights[i][0]].push_back({flights[i][1], flights[i][2]});
        }
        priority_queue<vector<int>> pq;
        vector<int> visited(n, INT_MAX);

        visited[src] = 0;
        pq.push({k + 1, src, 0}); // hop,node,price_till

        while (!pq.empty()) {
            auto front = pq.top();
            pq.pop();
            int node = front[1];
            int hop = front[0];
            int price_till = front[2];

            for (auto itr : m[node]) {
                int new_wt = price_till + itr.second;
                if (new_wt < visited[itr.first] && hop > 0) {
                    visited[itr.first] = new_wt;
                    pq.push({hop-1, itr.first,new_wt});
                }
            }
        }
        return visited[dst] == INT_MAX ? -1 : visited[dst] ;
    }
};