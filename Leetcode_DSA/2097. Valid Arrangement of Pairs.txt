class Solution {
public:
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        unordered_map<int, vector<int>> adj; // graph
        int n = pairs.size();
        unordered_map<int, int> indegree;
        unordered_map<int, int> outdegree;
        for (auto i : pairs) {      // mapping graph and in and out degrees
            adj[i[0]].push_back(i[1]);
            indegree[i[1]]++;
            outdegree[i[0]]++;
        }
        int start = -1;
        for (auto& i : adj) {
            int node = i.first;
            if (outdegree[node] - indegree[node] == 1) {
                start = node;       // finding starting node
            }
        }
        if (start == -1) {          // no start fount i.e. its eularian circuit and any point is starting point
            start = pairs[0][0];    // eularian circuit so we give any point to start
        }
        // logic to find path
        vector<int> path;
        stack<int> st;
        st.push(start);
        while (!st.empty()) {
            int top = st.top();
            if (adj[top].size() > 0) {
                st.push(adj[top][adj[top].size() - 1]);
                adj[top].pop_back();
            } else {
                path.push_back(top);
                st.pop();
            }
        }
        reverse(begin(path),end(path)); // reverse the path as stack gives us reversed path
        // logic to convert path into path pairs i.e. 1 2 3 => [[1,2],[2,3]]
        vector<vector<int>> res;
        for (int i = 0; i < path.size() - 1; i++) {
            res.push_back({path[i], path[i + 1]});
        }
        return res;
    }
};