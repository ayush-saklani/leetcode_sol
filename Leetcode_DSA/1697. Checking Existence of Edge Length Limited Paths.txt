https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/

class Solution {
public:
    int find(vector<int>& parent, int x) {
        if (parent[x] == x) {
            return parent[x];
        } else {
            return parent[x] = find(parent, parent[x]);
        }
    }
    void unionx(vector<int>& parent, vector<int>& rank, int x, int y) {
        int par_x = find(parent,x);
        int par_y = find(parent,y);
        if (par_x != par_y) {
            if (rank[par_x] >= rank[par_y]) {
                parent[par_y] = par_x;
                rank[par_x] += rank[par_y];
                rank[par_y] = 0;
            } else if (rank[par_x] < rank[par_y]) {
                parent[par_x] = par_y;
                rank[par_y] += rank[par_x];
                rank[par_x] = 0;
            }
        }
    }
    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
        vector<int> rank(n, 1);
        vector<int> parent(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        for(int i =0;i<queries.size();i++){
            queries[i].push_back(i);
        }
        sort(queries.begin(),queries.end(),[](auto &a, auto &b){ return a[2] < b[2]; });
        sort(edgeList.begin(),edgeList.end(),[](auto &a, auto &b){ return a[2] < b[2]; });
        int j = 0;
        vector<bool> res(queries.size(),false);
        for(int i =0;i<queries.size();i++){
            int limit = queries[i][2];
            while(j<edgeList.size() && edgeList[j][2]<limit){
                unionx(parent,rank,edgeList[j][0],edgeList[j][1]);
                j++;
            }
            if(find(parent,queries[i][0]) == find(parent,queries[i][1])){
                res[queries[i][3]] = true;
            }               
        }
        return res;
    }
};

// basically sort the queries according to weight limit 
// and query also according to weight limit

// Note : keep the query index intact before sorting as we have to return the answer in the original sequence

// now using DSU 
// iterate each query
// join all edges which are less than limit (they are in sorted form)
// find if they are have same parent => if yes then true else not possible to reach 
// and then again go to next query, union all edges of its limit and again continue