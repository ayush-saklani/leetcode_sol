class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int dir_x[] = {1, 0, 0, -1};
        int dir_y[] = {0, -1, 1, 0};
        int row = heights.size();
        int col = heights[0].size();

        if (row == 1 && col == 1) return 0;

        vector<vector<int>> effort(row, vector<int>(col, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> q;
        
        q.push({0, 0, 0});
        effort[0][0] = 0;

        while (!q.empty()) {
            auto top = q.top();
            q.pop();
            int currEff = top[0], x = top[1], y = top[2];

            for (int i = 0; i < 4; i++) {
                int nx = x + dir_x[i];
                int ny = y + dir_y[i];
                if (nx >= 0 && nx < row && ny >= 0 && ny < col) {
                    int diff = abs(heights[x][y] - heights[nx][ny]);
                    int newEff = max(currEff, diff);
                    if (newEff < effort[nx][ny]) {
                        effort[nx][ny] = newEff;
                        q.push({newEff, nx, ny});
                    }
                }
            }
        }

        return effort[row - 1][col - 1];
    }
};
