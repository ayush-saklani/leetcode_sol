https://leetcode.com/problems/find-eventual-safe-states/description/

class Solution {
public:
    bool dfs(const vector<vector<int>>& graph, vector<int>& state, int u) {
        if (state[u] == 1) return false; // found a cycle (back off)
        if (state[u] == 2) return true;  // already known safe (no cycle ahead)

        state[u] = 1; // mark as visiting
        for (int v : graph[u]) {
            if (!dfs(graph, state, v)) {    // if any cycle exist then back off as this is unsafe node
                return false;
            }
        }
        state[u] = 2; // all children safe -> mark safe
        return true;
    }
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> status(n, 0);
        for (int i = 0; i < n; i++) {
            if(status[i] == 0){
                dfs(graph, status, i);
            }
        }
        vector<int> res;
        for (int i = 0; i < n; i++) {
            if (status[i] == 2) {
                res.push_back(i);
            }
        }
        return res;
    }
};